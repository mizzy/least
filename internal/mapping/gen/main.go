//go:build ignore

// This program generates mapping code from CloudFormation resource schemas.
// Run with: go generate ./internal/mapping
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
)

type Schema struct {
	TypeName string   `json:"typeName"`
	Handlers Handlers `json:"handlers"`
}

type Handlers struct {
	Create *Handler `json:"create"`
	Read   *Handler `json:"read"`
	Update *Handler `json:"update"`
	Delete *Handler `json:"delete"`
	List   *Handler `json:"list"`
}

type Handler struct {
	Permissions []string `json:"permissions"`
}

type ResourceMapping struct {
	TerraformType string
	CfnType       string
	Create        []string
	Read          []string
	Update        []string
	Delete        []string
}

const outputTemplate = `// Code generated by go generate; DO NOT EDIT.
// Generated at: {{ .Timestamp }}
// Source: CloudFormation Resource Schemas

package mapping

// generatedMappings contains IAM permissions extracted from CloudFormation schemas.
// These are merged with fallbackMappings at runtime.
var generatedMappings = map[string]ResourceMapping{
{{- range .Mappings }}
	"{{ .TerraformType }}": {
		Create: []string{
			{{- range .Create }}
			"{{ . }}",
			{{- end }}
		},
		Read: []string{
			{{- range .Read }}
			"{{ . }}",
			{{- end }}
		},
		Update: []string{
			{{- range .Update }}
			"{{ . }}",
			{{- end }}
		},
		Delete: []string{
			{{- range .Delete }}
			"{{ . }}",
			{{- end }}
		},
	},
{{- end }}
}

func init() {
	// Merge generated mappings into fallback (generated takes precedence)
	for k, v := range generatedMappings {
		fallbackMappings[k] = v
	}
}
`

// cfnToTerraform maps CloudFormation types to Terraform types
var cfnToTerraform = map[string]string{
	"AWS::S3::Bucket":                           "aws_s3_bucket",
	"AWS::EC2::Instance":                        "aws_instance",
	"AWS::EC2::VPC":                             "aws_vpc",
	"AWS::EC2::Subnet":                          "aws_subnet",
	"AWS::EC2::SecurityGroup":                   "aws_security_group",
	"AWS::EC2::InternetGateway":                 "aws_internet_gateway",
	"AWS::EC2::NatGateway":                      "aws_nat_gateway",
	"AWS::EC2::RouteTable":                      "aws_route_table",
	"AWS::EC2::EIP":                             "aws_eip",
	"AWS::IAM::Role":                            "aws_iam_role",
	"AWS::IAM::ManagedPolicy":                   "aws_iam_policy",
	"AWS::IAM::Policy":                          "aws_iam_role_policy",
	"AWS::IAM::User":                            "aws_iam_user",
	"AWS::IAM::Group":                           "aws_iam_group",
	"AWS::IAM::InstanceProfile":                 "aws_iam_instance_profile",
	"AWS::Lambda::Function":                     "aws_lambda_function",
	"AWS::Lambda::Permission":                   "aws_lambda_permission",
	"AWS::DynamoDB::Table":                      "aws_dynamodb_table",
	"AWS::RDS::DBInstance":                      "aws_db_instance",
	"AWS::RDS::DBCluster":                       "aws_rds_cluster",
	"AWS::ECS::Cluster":                         "aws_ecs_cluster",
	"AWS::ECS::Service":                         "aws_ecs_service",
	"AWS::ECS::TaskDefinition":                  "aws_ecs_task_definition",
	"AWS::EKS::Cluster":                         "aws_eks_cluster",
	"AWS::EKS::Nodegroup":                       "aws_eks_node_group",
	"AWS::Logs::LogGroup":                       "aws_cloudwatch_log_group",
	"AWS::CloudWatch::Alarm":                    "aws_cloudwatch_metric_alarm",
	"AWS::SNS::Topic":                           "aws_sns_topic",
	"AWS::SQS::Queue":                           "aws_sqs_queue",
	"AWS::SecretsManager::Secret":               "aws_secretsmanager_secret",
	"AWS::SSM::Parameter":                       "aws_ssm_parameter",
	"AWS::KMS::Key":                             "aws_kms_key",
	"AWS::CertificateManager::Certificate":      "aws_acm_certificate",
	"AWS::Route53::HostedZone":                  "aws_route53_zone",
	"AWS::Route53::RecordSet":                   "aws_route53_record",
	"AWS::CloudFront::Distribution":             "aws_cloudfront_distribution",
	"AWS::ElasticLoadBalancingV2::LoadBalancer": "aws_lb",
	"AWS::ElasticLoadBalancingV2::TargetGroup":  "aws_lb_target_group",
	"AWS::ElasticLoadBalancingV2::Listener":     "aws_lb_listener",
	"AWS::StepFunctions::StateMachine":          "aws_sfn_state_machine",
	"AWS::Events::Rule":                         "aws_cloudwatch_event_rule",
	"AWS::Cognito::UserPool":                    "aws_cognito_user_pool",
	"AWS::Kinesis::Stream":                      "aws_kinesis_stream",
	"AWS::ECR::Repository":                      "aws_ecr_repository",
	"AWS::WAFv2::WebACL":                        "aws_wafv2_web_acl",
	"AWS::AutoScaling::AutoScalingGroup":        "aws_autoscaling_group",
	"AWS::CloudTrail::Trail":                    "aws_cloudtrail",
	"AWS::Glue::Database":                       "aws_glue_catalog_database",
	"AWS::Athena::WorkGroup":                    "aws_athena_workgroup",
	"AWS::Backup::BackupVault":                  "aws_backup_vault",
}

func findProjectRoot() string {
	dir, err := os.Getwd()
	if err != nil {
		return "."
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "."
		}
		dir = parent
	}
}

func main() {
	// Find project root by looking for go.mod
	root := findProjectRoot()
	schemaDir := filepath.Join(root, "internal/schema/data")
	outputFile := filepath.Join(root, "internal/mapping/generated.go")

	entries, err := os.ReadDir(schemaDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading schema directory: %v\n", err)
		fmt.Fprintf(os.Stderr, "Run scripts/fetch-schemas.sh first to download schemas\n")
		os.Exit(1)
	}

	var mappings []ResourceMapping

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".json") {
			continue
		}

		path := filepath.Join(schemaDir, entry.Name())
		data, err := os.ReadFile(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: could not read %s: %v\n", path, err)
			continue
		}

		var schema Schema
		if err := json.Unmarshal(data, &schema); err != nil {
			fmt.Fprintf(os.Stderr, "Warning: could not parse %s: %v\n", path, err)
			continue
		}

		tfType, ok := cfnToTerraform[schema.TypeName]
		if !ok {
			// Skip schemas we don't have a Terraform mapping for
			continue
		}

		mapping := ResourceMapping{
			TerraformType: tfType,
			CfnType:       schema.TypeName,
		}

		if schema.Handlers.Create != nil {
			mapping.Create = schema.Handlers.Create.Permissions
		}
		if schema.Handlers.Read != nil {
			mapping.Read = schema.Handlers.Read.Permissions
		}
		if schema.Handlers.Update != nil {
			mapping.Update = schema.Handlers.Update.Permissions
		}
		if schema.Handlers.Delete != nil {
			mapping.Delete = schema.Handlers.Delete.Permissions
		}

		mappings = append(mappings, mapping)
	}

	// Sort by Terraform type for consistent output
	sort.Slice(mappings, func(i, j int) bool {
		return mappings[i].TerraformType < mappings[j].TerraformType
	})

	if len(mappings) == 0 {
		fmt.Println("No schemas found to generate from")
		fmt.Println("Run scripts/fetch-schemas.sh first to download schemas")
		os.Exit(0)
	}

	tmpl, err := template.New("mappings").Parse(outputTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	data := struct {
		Timestamp string
		Mappings  []ResourceMapping
	}{
		Timestamp: time.Now().Format(time.RFC3339),
		Mappings:  mappings,
	}

	if err := tmpl.Execute(f, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d mappings\n", outputFile, len(mappings))
}
